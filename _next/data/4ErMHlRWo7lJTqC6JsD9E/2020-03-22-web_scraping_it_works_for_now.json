{"pageProps":{"frontMatter":{"title":"Web Scraping, it works... for now","date":"Mar 22nd, 2020","description":"Web scraping with nokogiri and Ruby","tags":["functions","javascript"]},"slug":"2020-03-22-web_scraping_it_works_for_now","mdxSource":{"compiledSource":"var p=Object.defineProperty,g=Object.defineProperties;var c=Object.getOwnPropertyDescriptors;var o=Object.getOwnPropertySymbols;var s=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;var h=(e,t,n)=>t in e?p(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,i=(e,t)=>{for(var n in t||(t={}))s.call(t,n)&&h(e,n,t[n]);if(o)for(var n of o(t))r.call(t,n)&&h(e,n,t[n]);return e},l=(e,t)=>g(e,c(t));var d=(e,t)=>{var n={};for(var a in e)s.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(e!=null&&o)for(var a of o(e))t.indexOf(a)<0&&r.call(e,a)&&(n[a]=e[a]);return n};const makeShortcode=e=>function(n){return console.warn(\"Component \"+e+\" was not imported, exported, or provided by MDXProvider as global scope\"),mdx(\"div\",i({},n))},SyntaxHighlighter=makeShortcode(\"SyntaxHighlighter\"),layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var a=n,{components:e}=a,t=d(a,[\"components\"]);return mdx(MDXLayout,l(i(i({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"Hello, welcome to my second blog post. In this section I will be going over web scraping using nokogiri and hopefully assist people getting over the same hurdles I did when tackling this task.\"),mdx(\"p\",null,\"So lets start off with the biggest thing there will be a lot of back and forth so when you are ready to start coding your scraper be prepared to be debugging for a while.\"),mdx(\"p\",null,\"To get everything started you are going to want to use Nokogiri to get the information from the webpage you want to scrape from using a pretty straight forward command.\"),mdx(SyntaxHighlighter,{language:\"ruby\",mdxType:\"SyntaxHighlighter\"},`\n        doc = Nokogiri::HTML(open(url))\n    `),mdx(\"p\",null,\"Now to get this working you will need to require nokogiri and open-uri.\"),mdx(\"p\",null,\"Awesome! now we have a webpage's contents saved into a handy place in memory where we can work from.\"),mdx(\"p\",null,\"From here we will be searching the information we saved to the \",mdx(\"inlineCode\",{parentName:\"p\"},\"doc\"),\" variable. This is done by a method in Nokogiri named #css. To use this method we will be inspecting the webpage for tags and classes in the HTML. Luckily for us most developers reuse these classes for items that are similar, this is great that means we can find items that are the same to use for collections.\"),mdx(\"p\",null,\"In my case I was after these\"),mdx(\"p\",null,mdx(\"img\",i({parentName:\"p\"},{src:\"https://i.ibb.co/F66nbHn/event.png\",alt:null}))),mdx(\"p\",null,\"more importantly I was after the links so I could repeat the whole process again for each event page\"),mdx(\"p\",null,'To do this I had to search the html for useful classes and tags. I realized that the linkes were nested inside an h2 with the class name \"tribe-events-list-event-title\" hmm easy enough for now the next tag was of course an a tag since i was looking for links. At this point I knew I needed a collection of links that followed this pattern so using the map function seemed like the best bet as it returns an array of the new items working on so my line of code ended up being this'),mdx(SyntaxHighlighter,{language:\"ruby\",mdxType:\"SyntaxHighlighter\"},`\n        @links = @doc.css('h2.tribe-events-list-event-title a').map {|link| link['href']}\n    `),mdx(\"p\",null,\"So to this point, I scraped the events page for all the links to the events and saved them to an array. Unfortunately, this was only half the work I needed to do to get my program working.\"),mdx(\"p\",null,\"in each of these links was a page containing the name of the event, a date, and a description so I knew I needed to do this for each page so that means I need to use nokogiri to do so on each page. I decided to use an iterator to create an object for each page to make accessing all this information easier (also the project required I do that... but regardless).\"),mdx(\"p\",null,\"Since I did not need to return anything specific and I was simply doing all my work in the block of code the simple each iterator does the job.\"),mdx(\"p\",null,\"Just as a little background I used mass assignment in my Event class so only a hash is passed in to the method instead of a bunch of order specific arguments\"),mdx(SyntaxHighlighter,{language:\"ruby\",mdxType:\"SyntaxHighlighter\"},`\n        def initialize(attributes)\n            attributes.each {|key, value| self.send((\"#{key}=\"), value)}\n            save\n        end\n    `),mdx(\"p\",null,\"Now to operate on my \",mdx(\"inlineCode\",{parentName:\"p\"},\"@links\"),\" array\"),mdx(SyntaxHighlighter,{language:\"ruby\",mdxType:\"SyntaxHighlighter\"},`\n        @links.each do |link|\n            event_page = Nokogiri::HTML(open(link))\n            #:name, :date, :description\n            attributes = {}\n            attributes[:name] = event_page.css(\"h1.tribe-events-single-event-title\").text\n            attributes[:date] = event_page.css(\"h2 span.tribe-event-date-start\").text\n            attributes[:description] = event_page.css(\"div.tribe-events-single-event-description p\").first.text\n            e = Event.new(attributes)\n            @calendar.events = e\n        end\n    `),mdx(\"p\",null,\"It may seem like a lot is going on here but its really simple once you read through it really the worst part is combing through the web inspector in chrome to find the arguments for nokogiri\"),mdx(\"p\",null,\"Now, what this method does is create a new doc like we did to get the links using Nokogiri. Once its parse it saves the information from the specified areas to a key in a new hash named attributes, then it creates a new Event instance passing in the new hash and then adds it to the calendars events instance variable using an overwritten events= method\"),mdx(SyntaxHighlighter,{language:\"ruby\",mdxType:\"SyntaxHighlighter\"},`\n        def events=(event)\n            if event.is_a?(Event)\n                @events << event\n            end\n        end\n    `),mdx(\"p\",null,\"This checks to make sure the passed in argument is indeed an instance of Event and adds it to an array for easy management.\"),mdx(\"p\",null,\"So at this point everything is working fine and the program scrapes the information and displays it as it should but then comes the caveat of web scraping.... It's not a static website meaning when they change their website for any reason it has the potential of breaking my program. While it works now... there is no guaranteed longevity to my program. Luckily this is just a portfolio project to demonstrate object relationships and web scraping techniques as the fragility of wweb scraping definitly makes me uncomfortable and would deter me from using it for an end user application.\"),mdx(\"p\",null,\"So in conclusion... It works! for now...\"))}MDXContent.isMDXComponent=!0;\n","scope":{}}},"__N_SSG":true}